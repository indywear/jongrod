import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import crypto from "crypto"

/**
 * @swagger
 * /api/auth/verify-sso:
 *   post:
 *     summary: Verify SSO Token
 *     description: Validates a token generated by external-register and returns user data for auto-login.
 *     tags:
 *       - Auth
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *             properties:
 *               token:
 *                 type: string
 *     responses:
 *       200:
 *         description: Token valid, returns user data
 *       401:
 *         description: Token expired or invalid
 *       500:
 *         description: Internal server error
 */
export async function POST(request: NextRequest) {
    try {
        const { token } = await request.json()

        if (!token) {
            return NextResponse.json(
                { error: "Token is required" },
                { status: 400 }
            )
        }

        // Decode Token
        const decoded = Buffer.from(token, "base64").toString("utf8")
        const parts = decoded.split(":")

        // Expected format: userId:expiresAt:signature
        // If userId contains ':' it might break, but cuid shouldn't.
        // Let's use lastIndexOf for signature
        const lastColonIndex = decoded.lastIndexOf(":")
        const dataPart = decoded.substring(0, lastColonIndex)
        const signature = decoded.substring(lastColonIndex + 1)

        const [userId, expiresAtStr] = dataPart.split(":")
        const expiresAt = parseInt(expiresAtStr)

        // Verify Expiration
        if (Date.now() > expiresAt) {
            return NextResponse.json(
                { error: "Token expired" },
                { status: 401 }
            )
        }

        // Verify Signature
        const secret = process.env.NEXTAUTH_SECRET || "fallback-secret-change-me"
        const expectedSignature = crypto.createHmac("sha256", secret).update(dataPart).digest("hex")

        if (signature !== expectedSignature) {
            return NextResponse.json(
                { error: "Invalid token" },
                { status: 401 }
            )
        }

        // Fetch User
        const user = await prisma.user.findUnique({
            where: { id: userId },
        })

        if (!user) {
            return NextResponse.json(
                { error: "User not found" },
                { status: 404 }
            )
        }

        if (user.isBlacklisted) {
            return NextResponse.json(
                { error: "Account suspended" },
                { status: 403 }
            )
        }

        // Return User Data (Same format as login)
        return NextResponse.json({
            user: {
                id: user.id,
                email: user.email,
                phone: user.phone,
                firstName: user.firstName,
                lastName: user.lastName,
                role: user.role,
                avatarUrl: user.avatarUrl,
            },
        })
    } catch (error) {
        console.error("SSO Verification Error:", error)
        return NextResponse.json(
            { error: "Verification failed" },
            { status: 500 }
        )
    }
}
